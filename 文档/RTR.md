## chapter 2 图形渲染管线

管线的作用:给定虚拟摄像机和世界空间中的三维物体、光源等要素，生成渲染一个二维图像。管线是实时渲染的基础工具。

影响物体外观的因素：材质属性、光源、纹理、渲染方程。

本章具体介绍渲染管线的不同阶段，并着重于管线功能而不是实现。

### 2.1结构（architecture）

管线分成很多stage，每个stage并行执行，每个stage依赖前一个stage的输入。

使用管线的目的：一个使用管线的、有n个stage的系统，理想状态下比相同的非管线系统可以加速n倍。

RTR将渲染管线粗糙划分成4个stage：application、geometry processing、rasterization、pixel processing。每个stage之间并行，并且内部还有substages，组成了subpipeline。

![image-20201029125747782](C:%5CUsers%5Czca%5CDesktop%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201029125747782.png)

**application:** 即应用层，在软件和cpu上实现，cpu的多核多线程并行特性，可以很好地响应应用层的各种需求，如传统的碰撞检测、物理仿真、全局加速算法等，虽然很多这些已经往GPU上移植了。

**geometry processing：**处理坐标变换，透视投影和其他几何操作。该阶段处理了画什么、怎么画、画哪里的问题，可以对应到vertex and geometry shader阶段。

**rasterization:**将每个图元进行光栅化变成像素。

**pixel processing：**对已经像素化后的渲染图片做像素级别的后处理。后三个阶段都并行运行在gpu上。



### 2.2 application stage

应用层作用：应用层在cpu端，作用是根据任务需要获取对应的几何数据信息，向下一stage发送所需的rendering primitives（渲染图元），如点线面三角形等。



### 2.3 geometry processing

该statge又可以分成下图4个substages。

![image-20201029132733374](C:%5CUsers%5Czca%5CDesktop%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201029132733374.png)

#### 2.3.1 vertex shading

**作用：**计算顶点位置，并决定需要什么顶点输出数据，如法线？纹理坐标？对标vertex shader。

随着现代GPU的发展，并且大部分的shading都是逐像素发生的，vertex shading变得更加一般或者固定化，可能完全不涉及渲染方程的计算。

**顶点位置的计算与坐标变换：**

模型一开始在自己的局部模型空间下，经过model矩阵变换到世界坐标和空间，世界空间是独一无二的，每个模型乘了model矩阵后就存在于同一个空间下。

相机在世界空间下有一个坐标和朝向，只有能被相机观察到的模型才能被渲染出。为了进行后续的投影和裁剪，模型和照相机都要从世界空间变换到视图空间（view space or eye space），即以照相机位置为原点，照相机朝向为-z轴、向上为y轴、向右为x轴的一个坐标系，这个变换需要一个view矩阵。

#### 2.3.2 可选的顶点处理

**tessellation shader：**用于三角形的合并，减少高面片在远处时的性能消耗。

**geometry shader:**输入一个图元的数据，可以将一个图元做变换切割，变成多个其它不同类型的图元。

#### 2.3.3 投影和裁剪 projection and clip

通过定义一个立方体或者平截头体的view volume（给出近平面和远平面的z值和FOV），有效坐标范围为（-1，-1，-1)到（1,1,1），将视图空间变换到这个view volume中，称为投影变换，分为透视和正交投影。经过投影变换后，对象进入了裁剪空间，落在单位view volume外的都要被裁剪掉不可见，这就是投影变换的作用。

#### 2.3.4 屏幕映射screen mapping

将处于view volume中的所有可见图元映射到屏幕空间上。虽然进入了看上去是二维的屏幕空间，此时的坐标仍然是三维的，相当于xy坐标被拉伸到和屏幕坐标范围一致，z坐标基本不变或根据api作一个映射，此时的屏幕坐标+z轴坐标被称为window coordinates。

关于整数和浮点数的点或纹理坐标如何和像素进行关联：

原先在屏幕空间中的点坐标是基于笛卡尔坐标系的，将屏幕像素在笛卡尔坐标系中建立映射即可。我们定义最左边像素的左边缘的坐标为0，那么这个像素的中央是0.5，因此第0到9个像素表示了浮点坐标系[0.0,10.0）的范围，0像素对应0-1,1像素对应1-2 etc。笛卡尔坐标系下的浮点坐标和像素下标的转换公式为：
$$
d=floor(c)\\
c=d+0.5
$$
d为像素下标的离散值，c是像素中心代表的浮点值。



### 2.4 光栅化

作用：根据屏幕空间中的带深度z的二维vertex构成的三角形，将其屏幕上像素化显示。光栅化可以认为是几何处理和像素处理阶段之间的一个同步点 ，他接收了几何处理阶段来的由三个点组成的三角形，将其像素化传给像素处理阶段。

光栅化可以分成三角形初始化、三角形遍历两个阶段。

三角形初始化：计算准备一些三角形的数据用于三角形的遍历，有专门的固定硬件来完成。

三角形遍历：检查中心(或样本)被三角形覆盖的每个像素，并为与三角形重叠的像素部分生成一个fragment，所以fragment shader就是给被三角形覆盖的像素着色用的，fragment的一些输入属性是由三角形三个顶点插值得到的，比如fragment的深度。由于一个像素可能被多个三角形覆盖，并且z-buffer位于光栅化之后，所以一个像素上可能执行多次fragment shader（正向渲染的弊端）。

光栅化在进入fragment shader之前进行，相当于为fragment shader 准备fragment。

### 2.5 像素级处理

#### 2.5.1 像素着色

pixel shading相当于fragment/pixel shader，进行逐像素的着色。这部分的输入有纹理和光照信息。

#### 2.5.2 合并结果（z-buffer）

每个pixel的颜色都存在一个颜色缓冲里，颜色缓冲存储的是什么最后输出到屏幕上的就是什么。由于每个像素可能被多个三角形覆盖，执行多次不同输入的fragment shader，因此需要根据一定规则来更新颜色缓冲,同时解决可见性的问题。该步骤也称为raster operation pipeline(ROP).

解决颜色缓冲和可见性的方案是z-buffer。z-buffer和颜色缓冲一样大小，只记录最小的z值（离观察点最近），当z值发生更新，同时更新颜色缓冲。opengl的z-buffer记录的值范围是0-1，与投影变换后的z在-1到1有一点差别，不过做个线性映射即可。

stencil buffer：是用于记录渲染图元位置的离屏缓冲区，一般只包含8bits。图元可以渲染到模板缓冲中 ，然后使用模板缓冲控制颜色缓冲和z-buffer的可见性，有点类似于蒙版mask。例如模板缓冲中已经画了一个圆结合一定的参数设置可以让颜色缓冲显示那个圆的部分。

framebuffer：帧缓冲一般包含上述提到的所有缓冲，包括深度缓冲、颜色缓冲、模板缓冲等。



### 2.6 管线总结

以一个CAD应用软件中操作一个华夫饼制作机为例，我们总结一下渲染管线是怎么运行的：

application：一个cad应用允许用户选择和移动载入模型的一部分。例如用户选择了一个盖子然后移动鼠标打开它，应用层必须将鼠标的移动转换成对应的旋转矩阵（geometry processing的数据获取），然后在渲染时将该矩阵应用到这个盖子上。

几何处理：假设应用程序提供了投影矩阵，view矩阵根据相机位置和朝向也能得到。对于每个对象都有自己的model矩阵，例如华夫饼机的底座有一个model矩阵，盖子也有一个model矩阵。在几何处理阶段对象顶点和法线会随着MVP矩阵变换进入裁剪空间得到最终在屏幕上的位置，再通过裁剪丢弃拉伸进入屏幕空间，进行下一步光栅化。同时给fragment shader传入对应在世界空间下的坐标，在世界坐标下更为方便地计算光影和材质纹理。

光栅化：所有经过裁剪后的可见图元被光栅化成像素，传入像素化处理阶段。

像素处理：根据几何处理传入的数据，如世界坐标、纹理坐标、法线方向等，计算各像素的颜色信息。

最后请注意，本章讲述的渲染管线是实时渲染应用程序的api和图形硬件发展的结果，但并不是唯一的渲染管线，例如离线渲染通常使用微多边形管线来完成。



## chapter 3 GPU

### 3.5 vertex shader

​	GPU管线中进入的第一个stage。输入仅仅是顶点数据，然后对顶点数据及其依附的一些其他属性(如颜色、纹理坐标、法线向量)等进行修改，但不能减少也不能增加顶点数据，每个顶点由GPU单元独立并行处理。一般顶点着色器的作用是将顶点数据从世界空间变换到裁剪空间。

​	输入装配的工作在顶点着色器之前由驱动程序自己进行，对程序员不可见，主要的工作是根据顶点数据创建一个顶点。

​	顶点着色器可以实现的几种常见效果：顶点混合、关节动画、轮廓渲染、object generation from one mesh、分解变形、粒子生成

### 3.6 the tessellation stage

作用：根据输入的一系列顶点patch渲染曲面，从而减少用更多的三角面片拟合曲面，使在远处看去能用更少的面片展现适当的细节。

使用tessellation的好处：使用曲面描述更紧凑，节省内存空间；

可以避免CPU和GPU之间的总线成为动画角色或对象的瓶颈，因为动画角色或对象的形状在每帧中都会发生变化。

tessellation分为三步：hull shader, tessellator, and domain shader

hull shader:输入给hull shader的是一个特殊的 patch primitive，他包含若干个控制点，控制点定义了细分曲面、bezier patch或其他类型的曲线元素。hull shader告诉下一步的tessellator应该生成多少个三角形，并执行对每个控制点的处理。

![image-20201102163044803](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201102163044803.png)

tessellator是固定功能的函数，主要功能是加入了一定数量的顶点给下一阶段进行处理。



### 3.7 geometry shader

作用：将一个图元变换到其它图元。

几何着色器的行为在考虑资源和内存需求时是最不可预测的，因为它是完全可编程的。在实践中几何着色器通常认为没什么用,因为它并不好映射到GPU的优势。在一些移动设备上，它是通过软件实现的，所以在那里它的使用是被不鼓励的

#### 3.7.1 流式输出

正常走流水线执行完vertex shader的结果是不可见的，直接就进后续的光栅化和pixel shader 了，我们可以选择关掉光栅化步骤走一个完全非图像的流式处理，执行完vertex shader和pixel shader后送回流水线的起始处迭代处理，这对仿真水或其它粒子特效很有帮助。



### 3.8 pixel shader

在geometry shader后图元被裁剪并准备光栅化，裁剪和光栅化相对固定不可编程，只能进行一定程度的配置。

fragment的定义：光栅化阶段遍历每个三角形，判断每个pixel被多少个三角形覆盖，每个像素被一个三角形部分或者全部覆盖都会产生一个fragment。



pixel/fragment shader的功能：

计算输出pixel的color、计算不透明度值、修改z值、丢弃fragment的输出。

一开始的pixel shader 只能输出到merge阶段，根据z-buffer对color和depth缓冲区进行merge。随着硬件发展一个像素着色器可以执行的指令数量的增加，可以支持多渲染目标（MRT),可以为每个fragment生成多个值保存到不同的缓冲区。

MRT的特性催生了另一种称为延迟渲染的渲染管线，该管线将可视性和着色部分分两个通道单独处理。

pixel shader的限制在于它无法得到周围的pixel的当前结果，自己的结果也无法影响周围的pixel。如果要综合邻接的pixel要使用图像后处理。

不过pixel shader提供了沿xy屏幕轴每个像素任何插值变化的量，这些量用来计算梯度和导数，间接反映了相邻片段的信息。

现代GPU使用一个2*2的quad来计算这些变化量。

![image-20201103154024163](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201103154024163.png)

避免 data race condition问题，即数据冲突问题。一个着色器的两次调用不能同时向同一个地方修改内容。GPU使用着色器可以访问的专用原子单位来避免这个问题。

### 3.9 合并阶段（merge）

在合并阶段发生深度缓冲和颜色缓冲的更新，一般涉及到模板缓冲和z-buffer的判断。颜色缓冲的更新对于不透明的物体就是直接代替原先存储的值，对于半透明的物体进行颜色混合操作。

由于z-buffer的深度测试进行在pixel shader后，导致很多pixel shader的执行是无效的，因为他们会被覆盖。因此许多GPU在pixel shader之前就进行了merge test，将深度测试提前，称为early-z。DX11和opengl4.2对pixel shader都强制开启了early-z测试，这样的话pixel shader无法修改z值也无法抛弃fragment。



### 3.10 计算着色器

DX11引入了计算着色器，计算着色器由api调用，可以和渲染管线中任一部分结合，主要作用是类似cuda核那样的并行计算？



## chapter 4 变换（transform）

线性变换：

满足以下两个等式的函数映射称为线性变换：
$$
f(x)+f(y)=f(x+y) \\
kf(x)=f(kx)
$$
例如f(x)=5x就是一个线性变换，这个函数变换也称为缩放变换，还有旋转变换也是一种线性变换，包括旋转缩放在内的对三维向量的所有线性变换，都可以用一个3×3的矩阵表示。

但是平移变换不是线性变换，不能和线性变换以统一的形式表示，但是平移操作又很有用，因此我们引入仿射变换(affine transform),仿射变换=线性变换+平移，通过引入齐次坐标维度，向量的w为0，点的w为1，仿射变换可以用一个4×4的矩阵统一表示。

所有的变换包括旋转、缩放、平移、反射、剪切都是仿射变换，放射变换的特征是保证变换后物体的线与线之前的平行关系不变，变换前是平行那变换后也是平行，但是长度和角度的变化幅度都不保证。

### 4.1 基础变换

**平移**：

![image-20201104160908592](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201104160908592.png)

**旋转：**![image-20201104160923892](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201104160923892.png)

在p点就地旋转：

![image-20201104161036266](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201104161036266.png)

**缩放：**

![image-20201104161059260](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201104161059260.png)

对称：缩放矩阵中s分量为-1即发生对称，如果有两个分量为-1则为旋转180°。

沿物体局部坐标系缩放：

设物体局部坐标系的三个坐标轴向量为**fx,fy,fz**,那么有坐标系变换矩阵：

![image-20201104163441690](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201104163441690.png)

![image-20201104163454900](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201104163454900.png)

即将物体局部坐标系做反变换FT到原点坐标系，再做缩放变换S，再变换回局部坐标系，和就地旋转是一个思路。



**剪切shearing**:有6个基础剪切矩阵，以$H_{xz}(s)$为例，第一个下标表示被剪切矩阵改变的坐标，第二个下标表示以该坐标的值的大小进行不同程度的裁切。

![image-20201105112525735](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201105112525735.png)

剪切矩阵如下所示：

![image-20201105113329282](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201105113329282.png)

对点p（px，py，pz）最终造成的结果是变换成（px+spz,py,pz).

还有一种两个参数的剪切矩阵$H_{xy}(s,t)=H_{xz}(s)H{yz}(t)$



**矩阵的连接**：由于矩阵乘法不具有交换性，矩阵的连接结果是和矩阵顺序相关的。如下图所示，先旋转还是先缩放的结果完全不同。

![image-20201105114126396](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201105114126396.png)

一般地我们将多个基础变换矩阵连接成一个大矩阵存储以提高效率，我们定义连接顺序为**C=TRS**，即先缩放再旋转最后平移。 



**刚体变换**：只包含平移和旋转的变换矩阵称为刚体变换，物体形状不发生变化。记为**X=T(t)R**.一般$X^{-1}$更为有用，将一个物体变换回世界原点，view矩阵就是这样操作得来的。$X^{-1}=(T(t)R)^{-1}=R^{-1}T(t)^{-1}=R^T(-t)$

**法线变换：**要将变换矩阵求**伴随矩阵的逆矩阵**，才能和法线进行运算，不然结果会出问题。

![image-20201105121924789](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201105121924789.png)



### 4.2 特殊的矩阵变换和操作

#### 4.2.1 欧拉变换

欧拉变换即用欧拉角作为参数输入，计算出一个旋转矩阵进行旋转变换。定义为：
$$
E(h,p,r)=R_z(r)R_x(p)R_y(h)
$$
根据旋转轴的先后不同E的形式不同，这里是最常见的一种形式。下面为旋转矩阵和欧拉角的转换方法

![image-20201105155724319](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201105155724319.png)

![image-20201105155744888](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201105155744888.png)

#### 4.2.2 矩阵分解

即从一个多个矩阵连乘的结果中分解出其中的部分矩阵，如平移旋转矩阵等。目前已经讲了两种分解方法，刚体变换矩阵可以很容易的分解出平移部分(最后一列)和旋转部分（3×3），旋转矩阵根据欧拉变换可以反计算出欧拉角hpr从而得到3个绕轴旋转的子矩阵。



#### 4.2.3 绕任意轴旋转

假设要绕r轴（向量表示）旋转α°，我们只需要用一个旋转矩阵M将r轴和世界坐标的x轴对齐，再绕x轴旋转，再用$M^{-1}$旋转回去即可。

已知一个轴是r，那么只需要找轴s和轴t使三轴组成正交基即可，正交基作为3*3就构成了$M^{-1}$。求s和t的方法感觉可以用s=cross（r,up),t=coss(s,r)，但是书里没用，主要是为了数值稳定性考虑，万一up和r取得方向太近会有问题。



### 4.3 四元数

#### 4.3.1 数学定义

![image-20201105163810772](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201105163810772.png)

qv是虚部，qw是实部。对于虚部可以进行任意的向量操作，如加法、缩放、点积、叉积等。



#### 4.3.2 四元数变换

单位四元数：单位长度的四元数有一个性质是可以表示任意的三维旋转变换。

纯四元数：实部为0只有虚部，即三维向量，一般用不粗体的字母表示。

定理1：

![image-20201106112629057](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201106112629057.png)

定理2：![image-20201106113047678](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201106113047678.png)

四元数**q、-q**表示的是同一个旋转，只是转的方向和角度不同，可以理解成一个顺时针转θ另一个逆时针转2π-θ，但结果一样。

![image-20201106114039672](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201106114039672.png)

**四元数插值**：使用四元数的一个很重要的好处就是方便插值，常用的插值法有Nlerp和Slerp。

Nlerp：对四元数线性插值再标准化，计算快但是角速度不是匀速。

![image-20201106114751345](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201106114751345.png)

Slerp：对四元数进行球面插值，角速度匀速。

![image-20201106115010539](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201106115010539.png)



ques：为什么用四元数对FPS相机的head和pitch增量转的时候会影响roll？

正常的欧拉角是记录head、pitch和roll，然后根据三个值按一定顺序乘上三个局部轴的旋转矩阵，相当于先绕x转pitch度，再绕经过第一次旋转后的局部坐标系的y轴转head度，再绕经过前两次旋转后的局部坐标系的z轴转roll。

如果是四元数的增量计算的话，比如我先绕x转了pitch度，再绕经过第一次旋转后的y轴转了head度，再绕经过前两次旋转后的x轴再转5度，这个效果是和直接绕x转pitch+5度完全不一样的，从最终的测试反推回roll的结果就是显示发生了变化。下图是先绕x轴再绕y轴再绕x轴的结果，roll发生变化了。

![image-20201107154744412](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201107154744412.png)



### 4.4 顶点混合（vertex blending）

顶点混合用于解决动画中连接骨骼的关节的灵活性的问题，又称为线性混合蒙皮（linear-blend skinning）。下图显示了对于上下臂之间关节是否使用顶点混合的差别，中间没使用，最右边使用了。

![image-20201107160748211](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201107160748211.png)

通常而言关节处的点会受到与其相连的多个不同骨骼的影响，我们通过对一个点叠加多个矩阵变换，这些矩阵变换来自不同骨骼，每个骨骼的矩阵变换都有人工设定的不同权值。用数学公式表示为：

![image-20201107161236158](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201107161236158.png)

其中p是初始关节顶点，u（t)是关节节点随时间变化的结果，矩阵M是将初始骨骼从局部坐标系变换到世界坐标系，这里取逆先将其放回原点，方便进行旋转等世界变换，$B_i(t)$对应随时间变化的骨骼世界变换矩阵，一般包括多个矩阵连乘，M矩阵其实也可以算在B里。

线性混合蒙皮的缺点是可能会发生不必要的折叠、扭曲和自交，更广泛使用的解决方案是对偶四元数，但他可能会产生鼓包。



## chapter 4 着色基础



#### 4.1 着色模型

Gooch shading model：一种早期的NPR模型，类似于普通素描关系的材质球，有高光、亮面、暗面。

![image-20201117164938681](F:%5Czca%5Clearnopengl%5CRTR.assets%5Cimage-20201117164938681.png)

数学描述：
$$
\bold{c}_{shaderd}=s\bold{c}_{highlight}+(1-s)(t\bold{c}_{warm}+(1-t)\bold{c}_{cool})\\
c_{cool}=(0,0,0.55)+0.25\bold{c}_{surface}\\
c_{warm}=(0.3,0.3,0)+0.25\bold{c}_{surface}\\
c_{highlight}=(1,1,1)\\
t=\frac{(\bold n \cdot \bold l)+1}{2}\\
\bold r=2(\bold{n}\cdot\bold l)\bold n-\bold l\\
s=(100(\bold r \cdot \bold v)-97)^\mp
$$
其中$\mp$表示clamp（s,0,1），将s限制在0到1范围内。r是反射向量计算。