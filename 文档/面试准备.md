**1.自我介绍**

面试官你好，我叫朱昶安，来自浙大计算机专业，目前研二，专业方向是计算机图形学渲染相关，主要经历是基于图形API实现过一些渲染底层引擎和场景框架，还有一些glsl和unity shader编写的经验，然后我个人有美术基础，水平大概在能独立完成一些同人绘画作品，对常见的美术表现手法有了解，我主要想结合自己技术和美术方面的相对优势，因此来应聘技美这个岗位。

**具体做过什么项目或者demo：**

基于opengl图形api和现代渲染管线实现过一个小的渲染引擎，常见的元素包括渲染对象、相机灯光场景组织阴影都有实现，主要最复杂的工作是把pbr金属工作流结合进来实现了一下，包括贴图预计算和shader实现。

还有一个就是基于unity的卡通渲染shader，主要是对原神角色的卡通渲染效果进行研究然后自己实现了一些效果，比如二分光、描边、边缘光、金属质感、lightmap的使用。

其他的就比较久远了不说了。

**2.渲染管线**

应用层->几何处理阶段->光栅化->像素处理

应用层：为渲染准备数据、纹理、材质、光照等信息，并调用draw call。

几何处理阶段：vs->裁剪->透视除法进入NDC->屏幕映射

可选的有ts和gs。

**顶点着色器作用：**一般就进行MVP变换，也可以进行逐顶点着色，做顶点动画。

**细分着色器作用：**将一个patch图元细分成更多三角面片，有曲面控制和曲面计算两个可编程部分，曲面控制部分主要决定怎么细分patch，曲面计算部分和vs类似进行坐标变换。

**几何着色器作用**：输入一个图元的顶点数据，可以在gs里生成更多顶点，并变换为其他图元。

**Model怎么拆成TRS?**：T是最后一列先拿出来，然后是拆RS，对RS求转置，$(RS)^T=S^TR^T=SR^{-1},SR^{-1}RS=S^2$，得S，最后求R即可。

MVP变换：

model将对象从模型空间变换到世界空间。

view将对象从世界空间变换到view space/eye space。

projection将对象从view space变换到clip space，此时clip space是一个unit cube，一旦超出单位立方体就裁剪掉。

裁剪过程推导：此时表示unit cube坐标还是在四维齐次坐标系下的，要反过来求出unit cube的裁剪面的四维齐次坐标表示和线性插值因子u。

设两点连线与z=-1的平面交点坐标为(x_z,y_z,-K,K),我们有连线的两点坐标（x1,y1,z1,w1)和（x2,y2,z2,w2)，可以根据z和w的坐标解出线性插值的比例u和K。

裁剪完执行透视除法就不是线性的了，但是执行完透视除法才变到NDC，NDC的坐标值才是真的坐标值（因为此时w=1），此时才能进行屏幕映射。

光栅化阶段：三角形初始化、三角形遍历。

三角形初始化：计算三角形的边的方程、微分等，用于扫描线算法。

三角形遍历：遍历所有三角形看每个像素点是否被某个三角形覆盖，是则生成一个fragment。

像素处理阶段：fs->模板测试->深度测试。



**3.透明度混合/测试**

透明度测试就是小于一个alpha直接舍弃。

和顺序有关的混合方法：

1.先正常渲染不透明物体，开启ztest和zwrite。

2.对半透明物体排序，从远到近进行渲染和颜色混合，此时开启ztest但不开zwrite（实际上如果完美排序所有fragment开不开zwrite都无所谓，但一般不开zwrite渲染错误会少一点）。

顺序无关的混合方法：

1.depth peeling。用n个pass分别渲染出距离摄像机第n近的片元，然后逐层按透明度从前往后叠加，这样可以不渲染完只渲染固定pass。

2.用一张2d图像纹理，每个像素记录一个该位置处的片元颜色链表，然后再叠加颜色。

screen-door transparency（点阵像素剔除半透明）：将普通的非透明渲染对象通过透明度mask进行测试剔除的方法剔除像素获得近似半透明的效果。



**延迟渲染**

先渲染一个pass把要用的数据存到g-buffer里，通过z-buffer筛一遍要被丢弃的片元，第二个pass根据g-buffer的数据再逐像素计算光照。延迟渲染很适合用于光源很多的场景因为可以减少很多光照计算。





**四元数的理解？参数代表的含义**：可以用来表示空间中任意两个向量之间的旋转角，四元数的实部代表cosθ/2，虚部代表**u** · sinθ/2。四元数很方便插值，快的是线性插值，慢的是球面插值但过程角速度匀速。



**阴影算法，PCF,PCSS,VSM?**

PCF，把shadow map邻接的深度也拿出来判断是否在阴影中，对结果求一个平均代表该点的柔和程度。

PCSS，先假设光源是个area light，从光源视角记录遮挡物的深度值，然后计算光源到遮挡物的平均距离、光源到投影物的距离，假设遮挡物、投影物、光源平行，用一个相似三角形解出半影区域的范围，再和其它算法结合。

**屏幕空间的阴影算法**：先正常渲染场景记录相机看过去的场景深度图，再从光源记录一张深度图，再在屏幕空间做一次阴影收集，根据屏幕坐标+场景深度转回世界空间坐标，再转到光视角下比较深度，判断该屏幕像素是否有阴影并记录一张阴影图。最后正常渲染的时候对阴影图采样就行，根本思想还是延迟渲染先渲染一遍记录深度避免不必要的光照计算。

**CSM及其优化：**将视锥平行切成几块，每块生成一张同分辨率的shadow map，这样越近采样率越高。

优化：如果某个shadowmap对应的视锥内的东西是固定的，shadowmap计算一次就行。远的shadowmap精度要求不高可以用粗糙模型，而且更新频率可以降低，或者用静态阴影贴图代替。

**deep shadow map**：可以用于半透明物体如头发这种阴影的渲染，除了记录深度还记录一个光的衰减系数。	

**PBR整理**

对pbr的理解：基于物理指的是使用了基于物理的渲染方程光照模型，然后基于为表面建模，符合能量守恒，满足这三条的都是pbr。pbr在离线渲染中可以和ray tracing结合，在实时渲染中常说的pbr就是指金属或光泽度工作流那一套由disney发起的标准。

PBR概念：使用基于物理的渲染方程和微表面建模的光照模型来实现渲染的方法。

特点：能量守恒、基于物理brdf、基于微平面

pbr工作流：分为两种金属工作流metallic+roughness/光泽度工作流specular+shininess，金属工作流的非金属F0固定0.04，光泽度工作流可以自由调整非金属F0但是容易能量不守恒，而且需要两张rgb贴图+1张灰度贴图，金属工作流只需要一张rgb+2张灰度。

metallic体现的是材质的金属和非金属的混合占比，最终会影响菲涅尔项的输入F0和diffuse项的强度，因为纯金属只会产生specular，roughness表示对微表面粗糙程度的建模，反映了微表面法线和宏观主法线的差异程度，反映了能正确将入射光反射到视点方向的微平面占比，粗糙度越大反射会越模糊。

disney BRDF：迪士尼提出的一种pbr标准，有10个材质参数，实现了一种基于物理且方便调参的着色模型，并且允许两个材质的参数之间进行线性插值。他的实现实际上是金属brdf和非金属brdf根据金属度线性插值。

disney diffuse brdf:采用了一种新的经验模型，在兰伯特漫反射基础上加了视线方向和光线方向的影响。

disney specular brdf:采用了通用的cook-torrance brdf，即DGF三项。

D法线分布函数表示的是微平面法线的统计分布，D值越高表示输入的微平面法线方向占比越多，输入是微表面法线方向NdotH和粗糙度，输出是该微表面法线方向的在表面法线的占比。目前一般用GGX	

F是菲尼尔项，输入是视线和微表面法线的夹角和0度情况下的反射的占比，输出是不同角度看过去反射的占比。一般使用schlick近似

G是几何遮蔽项，描述微平面中相互遮挡的项，或者说光线能不被遮挡顺利完成射入射出交互的概率，一般采用分离遮蔽阴影型的G项，会拆成两项相乘，一块是光线方向的遮蔽，一块是视线方向的遮蔽。

兰伯特模型与brdf的联系：兰伯特模型属于传统的diffuse brdf模型，但不是基于物理的。



**渲染方程(反射部分)：**

$L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i$

$f_r(p,\omega_i,\omega_o)$:BRDF双向反射分布函数，功能是简单来说就是和位置和入射方向有关的出射光线的能量分布占比，输入为位置p,入射方向ωi，出射方向ωo，描述的是在点p位置，从ωi入射一个光，从ωo方向反射出的光线相对入射光线的能量占比。一般会分成两个diffuse和specular的brdf模拟不同项。

$L_i(p,\omega_i)$:入射光的radiance。

n·wi:入射光与法线夹角。

$L_o(p,\omega_o)$:从wo方向出射的radiance。

**IBL**

对HDR采样和预处理贴图生成：

diffuse brdf的irradianceMap：以法线中心作一个半球采样环境贴图，采样到的颜色值当做入射光的radiance，预计算diffuse brdf的积分，使用的时候就用法线方向采样irradianceMap，取出来的就是这个法线朝向接收到环境的漫反射光。

specular brdf由于与入射方向和出射方向都有关，为了实时计算采用分割求和近似方法，将积分分成两块乘积分别预计算，得到一个prefilterMap和一张2d的brdfLUT。

prefiltermap类似于irradianceMap的生成流程，但是采样不在半球中，是基于粗糙度和重要性采样的，因为镜面反射项的brdf分布比diffuse集中的多。

brdfLUT记录的是菲涅尔项F的系数和偏移积分ab，最终的这块的积分可以通过a*F+b得到，brdfLUT的预计算也是基于粗糙度和重要性采样的，采样向量获取的流程和prefilterMap基本一致。



**球谐光照：**只听说过，将周围环境光采样成几个系数，渲染的时候用这几个系数对复杂光照进行还原，性能好像很好，怎么做不懂涉及到很多数学推导。



**前向渲染的理解？unity forwardbase/add 渲染什么光照？：**前向渲染就是按渲染管线走一遍，在vs中做mvp变换，在fs中为每个片元计算颜色和光照，前向渲染一般限制光源数量，因为fs会对之后被抛弃的片元也计算颜色和光照，因此光源变多的情况下会很低效。

forwardbase渲染一个逐像素平行光，所有逐顶点光和SH光源。

forwardadd渲染一个额外的逐像素光。



**光照模型：**兰伯特、phong、bling-phong、cook-torrance模型、渲染方程

**逐片元操作（merge）：**即fs后的测试merge阶段，模板测试、深度测试、透明度测试/混合。

**延迟渲染/G-buffer结构：**颜色、法线、深度/位置，可以使用MRT在一个pass里渲染完多个缓冲。延迟渲染对多光源优化较好，但是无法处理透明物体，需要结合前向渲染。



**卡通渲染相关（ramp、lightmap制作、rim、outline）**

**实现整体思路：**跟平时自己画图的思路差不多，每实现一种效果相当于画了单独一层，然后用某种颜色混合模式和底色叠加，就叠加调参到觉得可以接受为止。主要实现的效果：二分、描边、边缘光、pbr金属感，然后用lightmap做了面部阴影。

**描边算法：**我这里用的是两个pass正背面剔除的算法，就是正常渲染一遍进行背面剔除，再在第二个pass里进行正面剔除并将顶点沿着法线方向扩张，让轮廓扩大一圈，合起来就有轮廓线的效果。实现起来主要解决了一些细节问题:

描边断边问题,原因：只是朝着平面法线方向扩张，如果面片之间有明显转角就会裂开，尤其是对立方体这样的物体。解决方案：不用模型导入的法线让unity自己计算平均法线解决。

根据摄像机远近动态调节线宽，原因：无论远近都是在clip space中扩张固定线宽，相机拉远描边会很粗。解决方案：根据顶点和相机距离算一个系数修正，参考的colin大神的修正方案。

问题：宽屏的粗细不一致。原因：坐标到屏幕空间后由于宽高比不一致乘的比例不一样，要对线宽乘宽高比修正。

优化：整个扩张过程在view space中实现，好处是距离相机平面的距离就是顶点z值，扩张也只用扩张xy。

其他的描边算法：基于图像空间深度和法线纹理的边缘检测算法、基于对象空间根据数学定义在应用层检测轮廓边并生成轮廓对象（优点方便风格化）

**二分光**：本质基于半兰伯特漫反射模型加个阈值，这部分要效果好感觉要调法线或者直接用画出来的lightmap，我刚开始了解怎么画美术资源，之前从纯shader的角度主要是对阴影加了smoothstep柔和渐变，再在后面其他层叠一些效果让瑕疵不是很明显。脸部的lightmap我找了美术资源试着用了一下。

**lightmap的生成和使用：**

生成：先画好几张固定角度的lightmap，然后生成各自二维sdf图，插值得到中间角度的sdf就生成了中间过程的阴影图，插值得到所有角度的阴影图后叠加起来求平均就是最后的lightmap。

使用：先求光在物体局部坐标系xz平面的投影，对他单位化，再分解到x和z轴上，求个光在局部坐标系上的前分量和右分量，我想的是光从正左/右侧照来脸刚好照亮一半，这个时候采样阈值0.5，正前方照来全照亮，这个时候采样阈值0，这样可以和我没用lightmap的二分光照阴影对应上，然后根据求的光分量和对应阈值推导个连续对应关系。

**边缘光实现**：用了菲涅尔项来实现，因为菲涅尔项本来就是在边缘处有较大的值，主要做了一个trick把边缘光和光线方向联系起来，因为一般卡渲的边缘光集中在光照方向，我就吧NdotL变换到0-1乘上去了。

**pbr结合：**主要是和环境贴图结合，画了一张metallic贴图，把衣服金属感做出来了，环境diffuse层的效果我用了一个变亮混合，让颜色没有那么明显不然会显得很脏。



**伽马矫正：**为了调和sRGB空间和自然光线性空间的矛盾产生的，我们用sRGB空间描述我们人眼对光的感受，但是很多算法是基于线性空间的不是rgb空间的，因此我们要对输入的纹理进行一个decode（乘2.2次幂）变到线性空间，执行完算法后输出颜色进行encode（乘1/2.2次幂）变到sRGB空间。**为什么是2.2次幂？**因为人眼感受到的srgb中的中灰（0.5,0.5,0.5)在自然光线性空间大概只有0.25，两个空间的转换就是2.2次幂的关系。

**ray marching:**

和ray tracing的思想有点想但是利用了sdf，从相机沿着某方向发出一条光线，根据世界中对象的sdf求所有对象到相机的最短距离d，然后光沿着这个方向走d，从新位置重复这个过程直到d足够小或者走了足够多次。

求法线：对物体距离场函数求个梯度就是物体的法线。

求阴影：从表面向光源进行ray marching，如果ray marching返回的距离小于表面到光源的距离，说明被挡住了，产生阴影。

**ray/path tracing**：每次发出一根光线，然后进入世界空间反射折射直到打到光源为止，path tracing本质就是在递归的解渲染方程，渲染方程的求解基于蒙特卡洛积分估计，每次和介质交互都会根据渲染方程计算出射radiance累加。



**法线贴图:**根据uv可以逐片元获取一个normal，这样可以不用顶点插值得到的法线，但由于随着物体的旋转世界空间中法线方向会变，一般会把法线贴图定义在切线空间中并且都指向正z方向，然后用一个TBN矩阵表示切线空间到世界空间的坐标变换。

**DCC软件中的法线方向和切线方向如何确定？**

法线方向就是顶点表面法线向量，切向量根据uv坐标+顶点坐标计算，如果有多套uv数据，会计算出多套切线方向。

**视差贴图:**类似于一个高度场纹理，使用的时候要转到切线空间计算，求出和高度场交点的uv并用此处的纹理值代替本应看到位置的颜色。

**bloom：**只知道基于屏幕后处理的，对要bloom的区域进行高斯模糊，然后再和原场景混合，中间还可以对模糊后的加个色调映射。

**广告牌**：就是一堆永远面朝视线方向的四边形纹理贴图，本质在构建旋转矩阵，用一个锚点+3个方向向量（其实就是一个旋转矩阵）描述位置和朝向。使用的时候可以结合几何着色器，从一个锚点扩张成一个四边形图元，然后再进行纹理贴图。

**3D作画和2D作画的一点思考：**

2D作画的特点：以最复杂的舞蹈为例，美感来源于动画特有的依赖少量张数的原画和中割完成一个动作带来的张力，还有一种现实视觉中不存在的卡顿感（中割较少的特有美感)，还有人物动起来后经过画师美化和夸张处理的头发和阴影变化。一言蔽之就是2D动画的不丝滑（但足以满足视觉连贯性）带来的独特美感。2D手绘舞蹈作画巅峰《偶像大师》。

3D作画的特点：虽然三渲二技术逐渐成熟，很多时候到了难以分辨的地步，但3D相比2D最显著的特点还是帧与帧之间的变化过于顺畅，变化内容相对较少，比较符合物理现实。



hr面试准备：

自我介绍 用原来的 加个籍贯

实习时间：6-9月 看导师什么时候放 不过自己在杭州比较方便 到时候6月不忙的话就早点过来。

爱好：看看动画、玩游戏、画图

职业规划：渲染方向的TA，自己技术出身，还是以技术上的自身发展为主。然后补齐一些美术工具使用和工作流程的了解，自己工作之余会花钱报班上课提升美术水平。

选择网易的原因：在杭州，实习方便，以后也想转正留在杭州。然后是大厂，新人培训规范，能够快速提高自己。

工作中遇到问题怎么解决：一般我会先尝试收集资料自己解决，如果发现难以解决会向实验室的同学或老师寻求建议或者指导。

有什么想问的。如果我有幸能进入网易，后续有什么对新人的指导培训机制？转正是要求实习满几个月呢？

优点：有责任心（眼前有要做的事就会一直考虑直到他结束）、学习能力强（本科的时候小跨考计算机、自学美术）、会自我反省接受他人批评（自己没处理好的事情会记很久时刻反省）

缺点：性格偏内向和慢热，除了工作上的内容和人主动交流可能不是很多。

加班的看法？东西没做完肯定会自觉加班，最好还是提高工作效率避免不必要加班。