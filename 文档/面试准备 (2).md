自我介绍（TA）：

面试官您好，我叫朱昶安，来自浙大计算机专业，目前即将研三，明年春季毕业，专业方向是计算机图形学，主要经历集中在渲染这块，包括像unity渲染开发和shader编写比较熟悉，也使用图形API实现过一些基本的渲染效果，目前我是在网易雷火这边当TA实习生，主要负责的工作是根据美术需求对一些风格化的定制效果进行实现。然后我有一些美术基础，平时空了喜欢画画，在工作中和美术交流也比较顺畅，能较好理解美术的意图，主要因为自己对画面效果渲染表现比较热爱，也想结合自己技术和美术上的相对优势，因此来应聘TA这个岗位。

自我介绍（程序）：

面试官您好，我叫朱昶安，来自浙大计算机专业，目前即将研三，明年春季毕业，专业方向是计算机图形学，主要经历集中在渲染这块，像基于openGL图形API实现过一些基本的图形学算法，对常见的渲染效果比较熟悉， 最近主要用unity做开发比较多，对unity 提供的最新的几个管线都有一些使用经验，也自己基于SRP搭建过管线尝试实现一些自定义效果。目前我是在网易雷火这边当TA实习生，主要负责的工作是根据美术需求对一些风格化的定制效果进行实现。谢谢。



抗锯齿相关：

FXAA：

特点：后处理、快速消耗小。

思想：根据亮度差判断是否为边缘，然后计算混合因子进行混合。混合因子的计算涉及到确定边缘像素纵横向（比较垂直和水平的梯度差）、边缘终点搜索（沿边缘法线平移0.5，计算边缘两种颜色的平均亮度，往两边搜索计算当前亮度，如果亮度差与平均亮度大于一个阈值则认为是边缘）、根据像素在边缘线段的位置计算混合因子。

SSAA：

暴力渲染4倍分辨率再压缩回去，理论上效果最优，实际没法用。

MSAA：

特点：基于硬件实现，会增加显存消耗，和延迟渲染结合不好。

思想：与SSAA近似使用4倍大小的颜色深度模板缓冲，每个像素有4个子采样点，但是像素只进行一次着色，如果子采样点通过深度模板测试，将像素的着色结果复制到4倍大小的颜色缓冲中的对应位置，最后对4个子采样点进行插值。

TAA：

特点：采样数高，复用历史帧信息，但是写不好会有残影和闪烁。

思想：将上一帧和当前帧按一定百分比混合，这样可以复用上一帧信息。



MLAA:

思想：检测边缘->对边缘进行模式识别归类->对不同模式的锯齿形态拟合原有的边缘，然后计算各像素的混合权重。

![img](https://img-blog.csdn.net/20171102161301557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWV6Y3d4MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

SMAA：
特点：基于图像后处理，思想基于MLAA，性能消耗接近FXAA，但效果比FXAA好，性价比高。



软阴影相关：

**shadow map原理：**从光视角采样记录深度成一个shadow map，在shading时将相机视角的shading point转到光视角下采样shadow map，比较深度值，如果遮挡则处于阴影中。做法就是声明一个temp FBO/RT，先用shadowCasterPass画这个RT得到shadow map，再正常渲染。

**cascade shadow map：**由于透视投影的存在，越近的地方我们需要shadow map的分辨率越高，这样shadow map的texel才能和画面的pixel对应上。将相机视角的视锥平行划分成大小不同的几块区域，越接近相机的区域越小，每块都单独渲染同分辨率的shadow map，这样越近的地方shadow map的一个texel对应的pixel就越准确。

![img](https://pic2.zhimg.com/80/v2-aa5273094b2a5a890932f3d4f5b44c7d_1440w.jpg)

实现中的难点：选择正确的cascade shadow map；不同cascade的切换过度，从光视角看去不同的cascade层级之间有交叠，可以在交叠区域中lerp，也可以用dither的方法，用高频掩盖低频。

**PCF：**对当前采样点周围一圈的shadow map也采样深度值并比较，统计一个平均被遮挡数作为软阴影程度。不同的filter采样选择效果不同，常见的filter有poison filter、tent filter

**PCSS：**动态filter大小的PCF，PCF的采样范围是固定的，PCSS根据一个搜索范围对shadow map先进行固定次数的随机采样，计算是遮挡物的采样点的平均距离（block search），然后根据这个距离利用相似三角形计算一个半影区域大小，根据区域大小作为filter大小计算PCF。

**VSM：**对PCSS/PCF的filter采样的进一步优化，不用逐个采样filter区域，直接得出近似结果。shadow map记录深度的同时记录深度的平方，利用这两个深度通道的MIPMAP或者SAT表计算shadow map区域的均值和方差，根据均值方差代入切比雪夫不等式近似得到这个filter中PCF的百分比值。

![image-20210715223028395](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210715223028395.png)

同时还优化了PCSS的block search，也是利用切比雪夫。

# ![image-20210715222923022](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210715222923022.png)

二维SAT建立：逐行计算一遍前缀和得到一个新二维数组，再对新数组逐列计算一遍前缀和。

**MSM（moment shadow mapping）：**

VSM会因为使用正态分布去强行估计，可能会估计不准造成漏光的问题。MSM采用了比VSM更高阶的矩，存了深度的一二三四次方，然后去恢复出一个分布，具体怎么恢复的分布不知道很麻烦。

**SDF软阴影：**

SDF阴影是从shading point朝着光源进行ray marching，如果第一个打到的物体不是光源则被完全遮挡，软阴影就是在ray marching过程中一直记录在打到光源前所有step中的最小距离，也就是在这次ray marching中打到光源前离最近的物体的距离，根据这个距离和到出发点的距离计算一个比值用来估计半影区域的大小。

**半透明阴影：**

半透明不会进行z write，但是只要自定义shadowCaster pass，然后在这个pass里开zwrite当不透明物体写入即可，如果是完全透明，在caster pass里采样进行clip，计算阴影的时候照常采样阴影贴图计算即可，因为阴影在光照计算的时候就只是个attenuation系数，只要能算光照那阴影肯定也有，主要是shadowCaster要处理对，如果需要额外增加透明度对attenuation的影响，需要额外在shadow map记录透明度。

shadow map问题：自遮挡、浮空，通过调一个和平面夹角有关的bias值解决。

**SRP项目相关：**

描边方案：two pass顶点扩张法，用了平均法线解决断边，顶点色控制宽度，zoffset掩盖面部扩张，基于深度的线宽衰减，。

面部sdf lightmap：

生成方法：手绘几个角度的二值阴影图，然后生成2d sdf并插值0-180角度，最后所有角度相加求平均。

使用方法：将光源摊平到局部空间的xz平面上去采样lightmap。将光源方向变换到当前渲染对象的local space中，向xz平面投影并单位化，再向x和z轴投影得到x和z光源分量，用这个光源分量去采样lightmap。

多层ramp：用两个smoothstep相减得到一个方形函数，上升和下降的阶跃变化都可以作为ramp值，就可以做出多层。

pbr的结合：

主要做了两点：1.增加物体受环境贴图IBL的影响。2.标识金属并用pbr微表面模型计算。

根据金属度来控制基本卡通渲染效果和pbr的融合程度。原先的卡渲效果作为diffuse保证整体风格还是偏平偏卡通，自己简单画了metallic和roughness的贴图用于标识metallic程度，再根据metallic程度，用微表面模型计算specular brdf并乘上一个缩放系数叠加到角色金属部分上。同时还加了IBL环境贴图的影响。

屏幕空间边缘光：类似于边缘检测，沿着某方向平移uv检测边缘差，大于阈值就是边缘光。可以将光源和法线投影到二维屏幕空间获得比较平和均匀的效果。

后处理：bloom、color grading、fxaa

bloom：多轮9*9的高斯滤波核模糊+亮度计算权重叠加回原图。优化：二维高斯核可拆成水平和竖直两次一维高斯核减小采样计算，并利用2\*2的硬件双线性插值将水平高斯核size减小为5。fireflies问题：基于亮度权重预过滤一遍，亮度越大权重越小，防止出现最后亮度特别大的值。

**openGL项目相关：**

openGL的api比较碎比较难用，因此尝试对常用组件进行封装，主要做的是实现了一下基于PBR微表面模型的IBL环境贴图预计算生成，实现了一下ue基于split sum的pbr shader。

**实验室项目相关：**

深度学习和航天控制相结合的一个纵向重大专项，简单说来就是要对地外探测的环境用深度学习做感知分析，判断地外环境的可通行性。网络就用的图像分割网络，主要涉及到用程序化的方法在仿真环境里收集制备数据集，训练倒是比较好收敛，对深度学习研究不是很深，只能说看过用过改过。

**CUDA项目相关：**

输入很多张不同视角的RGBD图片，恢复出在世界空间的点云，每个点云用一个很小的bounding box存储并组织成BVH，然后根据给定目标视角的深度去查BVH重建RGB信息，主要涉及到BVH如何在GPU存储，然后在GPU中查询递归爆栈的优化。

**实习工作相关：**

目前在那边一个月，做了的工作有：后处理描边基本的均匀款，按美术的需求尝试了一些方法进行风格化，有一些效果但不是很满意还在持续做；shell based风格化材质球，用shell的方法在外面套几层壳然后采样笔触纹理按照一定方法进行透明度剔除，就可以做出比较有手绘毛糙感的效果；3d sdf texture生成工具，并支持交并差布尔操作；自由视角遮挡半透效果，从角色到相机发出raycast检测所有打到的物体判断是否有东西遮挡，由于是全视角需要解决raycast从无到有的跳变问题，我用了正反两次ray检测并计算碰撞的distance差，用这个差传到shader进行过度。

常见三种实时描边做法：two pass+法线扩张、深度+法线检测后处理、几何着色器输入邻接图元检测夹角用退化四边形画出

线宽和颜色风格化：控制线宽可以用顶点色单通道控制、控制颜色也可以用顶点色的一个通道画，然后用通道值采样纹理。

场景描边多为后处理，一般线宽和颜色风格化程度有限，可以用深度、NdotV等算一个线宽权重进行控制，颜色控制也同理用一个参数去采样LUT贴图，控制颜色和混合程度。

场景笔触风格化：以某种方式采样笔触纹理、后处理风格化。



**基于物理的材质与微表面模型：**

微表面模型：

diffuse brdf: 兰伯特brdf

specular brdf:

NDF：法线分布函数表示微表面级别的法线统计分布，以粗糙度的形式表示微表面法线与主法线的一致程度，NDF输出某粗糙度下给定半程向量在表面法线的占比。

G：几何遮蔽项，微平面之间自遮挡引起的能量损失，当粗糙度过大时整体会因G项能量损失变暗，这部分损失可以用kulla-conty方法补上。

F：菲涅尔项，能量被反射的比例，剩下的能量被吸收或者折射，因此和物体的albedo有关，也和观察方向夹角有关，越接近掠角反射越强。

**kulla-conty:**补偿因几何遮蔽项没有考虑遮蔽带来的多次光线弹射造成的能量损失，通过经验模型预计算得到补偿项，使用时加上去即可。



**实时GI：**

RSM:shadow map中记录的深度在世界空间中恢复，就是所有受到直接光源照射的区域，将这些区域当做次级光源，并假设成diffuse材质对shading point进行光照计算即可。易于实现常用作手电筒。



SSR:在屏幕空间做ray tracing，对屏幕空间每个shading point恢复世界坐标，采样获得反射方向进行固定step的ray marching，每个step都计算当前位置的depth并采样gbuffer比较深度，如果非常接近认为反射打到次级光源，也就是打到的点的光照着色信息可以加到当前shading point里。



LPV:确定次级光源（和RSM一样用shadow map)，将次级光源放入预先划分的三维grid中传播radiance，着色的时候对shading point周围的grid取radiance然后计算间接光照。

VXGI:

pass 1：将场景划分成一个类似于八叉树的层次voxel结构，确定哪些voxel是次级光源。

pass 2: 基于图像空间，从camera出发向每个像素发出一个ray，根据打到的像素的材质反射出一个或多个cones，然后看打到了哪些次级光源。 

SSAO/HBAO/SSDO：

假设brdf是diffuse，入射radiance全为1，只考虑可见性来解渲染方程的积分。SSAO的做法基于屏幕空间，从每一个pixel做一个单位球然后撒点，判断这些点从camera是否被depth buffer挡住，统计被挡住的点的比例过半就开始有ao。



**环境光照：**

SH:

一系列球面上的二维基函数，类比于傅里叶级数展开表示一个函数，球谐函数用一系列二维基函数近似一个二维函数，将二维函数表示成一组基函数和对应的系数相乘的形式。球谐函数有不同阶数，用的阶数越多恢复的越好，但是一般只用低阶的，这样对低频的函数恢复的比较好，可以用球谐函数表示diffuse环境光照。

如何求SH系数？将待表示函数投影到基函数上，相乘求积分。如对环境光照，就把各方向采样到的环境光和基函数相乘再累加。

PRT(precomputed radiance transfer):预计算path tracing中的light transport并用SH保存，实时使用时直接用sh系数，缺陷是预计算时可见项都已经固定了，因此PRT方法下要求物体不能动。

![image-20210717215022735](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210717215022735.png)

IBL：

对环境光积分预计算为prefilter cubemap，这样采样的时候给一个方向就相当于采样到原先环境光一个区域加权平均后的值，这就是diffuse brdf的环境光irradiance map和specular brdf的环境光prefilter map的原理。

split sum：将一个积分近似拆成两个积分的乘积。经典做法如epic将微表面模型的specular brdf用split sum方法分别预计算出一张prefilter map和brdfLUT，其中brdfLUT是一张rg通道的二维纹理，通过拆菲涅尔项分离出baseColor的影响将积分从5维降到2维，再预计算存储。



**shader debug 技巧：**

对想要获取的一个值，用if语句进行判断其值域，满足则discard。以此方法不断二分，得到最终的值。

例如:

if(pos.x<0) discard; -> if（pos.x<5) discard;  if(pos<4) discard; if(pos.x<4.5) discard;



**shader优化相关：**

low level thinking，从减少shader生成的GPU汇编代码的角度考虑，不依赖编译器优化。

不同的写法生成的汇编代码不同，简单说来有以下原则：

多用mul+add的形式，会优化成MAD指令，而先add+mul则不会。

不要对常量在shader里做数学计算，可以展开直接得到结果的就直接写出来。一些固定的值可以在CPU算好的就先算好传进来，像矩阵之类的。

尽量使用内置函数。

少用if语句，尽量用宏定义和三目运算符（如果if被优化成了lt+movc汇编指令倒是影响不大，需要看if有没有在汇编中产生分支）



**基本渲染管线/一次draw call绘制流程：**

step1.CPU端准备数据。

准备顶点数据：申请VBO id，分配buffer，向buffer填充顶点数据，解释顶点数据etc。

准备全局变量：设置一些管线全局的状态，比如窗口大小，混合模式、是否ztest or zwrite，剔除模式等等，计算传入一些要用的uniform变量，比如相机矩阵。如果用到纹理要申请纹理id分配缓冲传纹理数据解释纹理最后将纹理id用uniform传入。

准备shader：要创建vs和fs并编译链接通过，并选择使用这个shader。

准备完毕后向GPU发draw call。

step 2.

几何处理阶段。一般必备的有顶点着色器，主要工作是进行MVP变换到裁剪空间，裁剪剔除掉视景体之外的部分，然后进行透视除法变到ndc空间。可选的还有几何着色器和细分着色器这些，几何着色器可以进行图元的变换，细分着色器可以将一个图元拆分成更多的图元。

理论上裁剪在透视除法前的任何阶段都可以，一种比较简单的裁剪算法是在clip space中对不符合![[公式]](https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%0A%5Cbegin%7Barray%7D%7Bccc%7D%0A-w%27+%3C+x%27+%3C+w%27+%5C%5C%5C%5C%0A-w%27+%3C+y%27+%3C+w%27+%5C%5C%5C%5C%0A0+%3C+z%27+%3C+w%27+%5C%5C%0A%5Cend%7Barray%7D%0A%5Cright.)****的点进行剔除并插值出新的顶点，ω是view space的-z，如果值为负表示看不到也直接丢弃。

step 3.

光栅化阶段，对ndc空间中可见物体进行光栅化，需要进行三角形初始化计算三角形边的方程和微分等数据，方便后续扫描线算法使用；然后进行三角形遍历，判断每个像素是否被这些三角形覆盖，如果是则生成fragment进行着色。

step 4.

像素处理阶段（着色），进行着色，可以做很多操作，着色完进入模板测试+深度测试。



如何判断多边形是凸多边形：

逆时针对相邻边两两做叉积p1p2 x p2p3，如果叉积均为正（顺时针方向）则为凸多边形。

光线与三角形求交：

光线方程代入重心坐标解出来，如果重心坐标有出现负数那么就没有交点，均为正数就有交点。

判断点在三角形（多边形）内外：

射线法，过点做一条射线交点为奇数在内部，偶数在外部。



色调映射：

从HDR转到LDR的颜色映射过程。

常用算法：reinhard、ACE、自己拟合。



反射向量推导：

R = normalize(2*dot(V,H)$\cdot$H-V)

phong模型 specular：exp(dot(R,V),shininess)

bling-phong模型 specular: exp(dot(H,N),shininess)



如何保证天空盒不遮挡其他物体：

画天空盒时手动将clip space的z值置为w，经过透视除法后z=1永远在最后面。



圆上任取3点构成锐角三角形概率？

1/4.等价于任取两点p1p2，取第三点p3形成的三角形包含圆心的概率，取第三点能包含圆心的概率=p1p2弧长期望占周长的比例，弧长最长为半圆，最小为0，期望为1/4圆，那么锐角三角形概率为1/4.



三角形之间求交：

平面三角形求交：两个三角形各枚举一条边两两求交+选一个三角形的3个顶点判断是否在另一个三角形内。

空间三角形求交（碰撞检测）：取一个三角形的三条边和另一个三角形的面求交，转化成3次线面求交。

